# Симуляционная модель морского порта

## Описание проекта

Дискретно-событийная симуляция работы морского порта для анализа пропускной способности, выявления узких мест и оптимизации логистических процессов.

**Веб-приложение**: https://portsimulator-yh67fp4m73pyahavovcpe4.streamlit.app

---

## Математическая модель

### 1. Теория массового обслуживания (Queueing Theory)

Порт моделируется как **система массового обслуживания** с несколькими типами серверов (причалы, краны, склады, ЖД).

#### Основные компоненты:

- **Входной поток**: Прибытие судов моделируется **пуассоновским процессом**
- **Очереди**: Суда ожидают освобождения ресурсов
- **Серверы**: Ресурсы порта (причалы, краны, пути)
- **Время обслуживания**: Зависит от объема груза и скорости разгрузки

---

## 1. Генерация судов (Ship Generator)

### Математика прибытия судов

**Пуассоновский процесс** — стандартная модель для случайных прибытий.

#### Формула интервала между судами:

```
λ = ships_per_year / 8760  (среднее количество судов в час)

T_inter = Exponential(1/λ)  (интервал между прибытиями)
```

Где:
- `8760` — количество часов в году
- `Exponential` — экспоненциальное распределение

#### Пример:
Если `ships_per_year = 714`, то:
```
λ = 714 / 8760 ≈ 0.0815 судов/час
Средний интервал = 1/λ ≈ 12.27 часов
```

---

## 2. Распределение типов грузов

### Формула выбора типа груза:

```
cargo_type ~ Categorical(p_grain, p_oil, p_general)
```

Где:
- `p_grain` — вероятность зернового груза
- `p_oil` — вероятность нефтяного груза
- `p_general` — вероятность генерального груза
- `p_grain + p_oil + p_general = 1`

### Объем груза на судне:

```
Зерно:    cargo = Uniform(3000, 8000) тонн
Нефть:    cargo = Uniform(5000, 15000) тонн
Генгруз:  cargo = Uniform(1000, 5000) тонн
```

---

## 3. Процесс обработки судна

### Этапы обработки:

```
┌─────────────┐
│  Прибытие   │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ Ожидание    │ ← ОЧЕРЕДЬ (если причалы заняты)
│ причала     │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ Швартовка   │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ Запрос      │ ← Только для сухих грузов
│ крана       │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ Ожидание    │ ← Ждем места на складе
│ склада      │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ Разгрузка   │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│Отшвартовка  │
└─────────────┘
```

### Время разгрузки:

```
T_unload = cargo_amount / unload_speed
```

#### Скорости разгрузки (по умолчанию):
- **Зерно**: 300 т/ч (конвейерная система)
- **Нефть**: 1000 т/ч (насосная система)
- **Генгруз**: 20 т/ч (портальные краны)

#### Пример расчета:
Судно с 6000 тоннами зерна:
```
T_unload = 6000 / 300 = 20 часов
```

---

## 4. Система складирования

### Логика размещения груза:

```python
if storage.level + cargo_amount > storage.capacity:
    WAIT  # Ожидание освобождения места
else:
    storage.put(cargo_amount)  # Размещение груза
```

### Емкости складов (по умолчанию):

- **Зерновой терминал**: 100,000 тонн
- **Общий склад**: 1,667 TEU = 20,004 тонн
- **Нефтебаза**: 540,000 тонн

**Формула перевода TEU в тонны:**
```
weight_tons = TEU × 12
```

Где `12` тонн — средний вес груженого 20-футового контейнера.

---

## 5. Железнодорожная логистика

### Процесс вывоза грузов:

```
Интервал между поездами = 24 / trains_per_day часов
```

#### Пример:
При 7 поездах в сутки:
```
Интервал = 24 / 7 ≈ 3.43 часа
```

### Приоритет вывоза:

```
1. Зерно        (высший приоритет)
2. Генгруз      (средний приоритет)
3. Нефть        (низший приоритет)
```

### Формула вывоза:

```
if grain_storage >= train_capacity:
    unload grain
elif general_storage >= train_capacity:
    unload general
elif oil_storage >= train_capacity:
    unload oil
else:
    unload mixed (берем с каждого склада)
```

### Вместимость поезда:

```
train_capacity_tons = train_capacity_TEU × 12
```

**По умолчанию**: 167 TEU = 2,004 тонн

---

## 6. Расчет пропускной способности

### Формулы для каждого элемента инфраструктуры:

#### 1. Причалы:

```
ships_per_year_capacity = total_berths × 8760 / avg_ship_time

berth_capacity_tons = ships_per_year_capacity × avg_cargo_per_ship
```

**Пример:**
- 10 причалов
- Среднее время обработки судна = 24 часа
- Средний груз = 5000 тонн

```
ships_per_year = 10 × 8760 / 24 = 3,650 судов/год
capacity = 3,650 × 5000 = 18.25 млн тонн/год
```

#### 2. Краны:

```
crane_capacity = cranes × general_speed × 8760 × efficiency
```

Где `efficiency = 0.7` (70% эффективность с учетом простоев)

**Пример:**
- 7 кранов
- Скорость = 20 т/ч

```
capacity = 7 × 20 × 8760 × 0.7 = 857,640 тонн/год
```

#### 3. Склады:

```
storage_capacity = total_storage × turnover_rate
```

Где `turnover_rate = 24` (24 оборота в год, т.е. груз хранится ~15 дней)

**Пример:**
Общая емкость = 660,004 тонн

```
capacity = 660,004 × 24 = 15.84 млн тонн/год
```

#### 4. ЖД инфраструктура:

```
railway_capacity = trains_per_day × train_capacity × 365
```

**Пример:**
- 7 поездов/сутки
- Вместимость = 2,004 тонн

```
capacity = 7 × 2,004 × 365 = 5.12 млн тонн/год
```

---

## 7. Определение узкого места (Bottleneck)

### Теория ограничений (Theory of Constraints):

Пропускная способность системы определяется **самым слабым звеном**.

```
system_capacity = min(berth_capacity, crane_capacity, storage_capacity, railway_capacity)
```

**Узкое место** — элемент с минимальной пропускной способностью.

### Загрузка системы:

```
utilization = (actual_cargo / system_capacity) × 100%
```

### Классификация загрузки:

```
< 60%   →  Есть значительный резерв
60-80%  →  Умеренная нагрузка
> 80%   →  Система на пределе
```

---

## 8. Ключевые метрики

### 1. Среднее время ожидания:

```
avg_wait_time = Σ(wait_time_i) / n_ships
```

**Критический уровень**: > 72 часа

### 2. Длина очереди:

```
queue_length = количество судов, ожидающих причал
```

**Критический уровень**: > 5 судов

### 3. Загрузка складов:

```
storage_usage = (current_level / capacity) × 100%
```

**Критический уровень**: > 95%

### 4. Годовой грузооборот:

```
annual_cargo = Σ(cargo_i) × (8760 / simulation_hours)
```

Где экстраполяция приводит результаты симуляции к годовым значениям.

---

## 9. Анализ точки коллапса

### Методология:

Постепенное увеличение нагрузки с шагом 10%:

```
load_multipliers = [1.0, 1.1, 1.2, ..., 3.0]

for multiplier in load_multipliers:
    ships_test = base_ships × multiplier
    run_simulation(ships_test)
    check_critical_metrics()
```

### Критерии коллапса:

```
1. Первые сбои        → 1 критический показатель
2. Постоянные задержки → 2 критических показателя
3. Полный коллапс      → 3 критических показателя
```

**Критические показатели:**
- Очередь > 5 судов
- Ожидание > 72 часа
- Склады > 95%

---

## 10. Стресс-тестирование

### Сценарии нагрузочного тестирования:

#### Сценарий 1: Рост нагрузки
```
ships_new = ships_base × 1.1  (+10%)
```

#### Сценарий 2: Пиковая нагрузка
```
ships_new = ships_base × 1.3  (+30%)
cargo_distribution = {grain: 50%, oil: 45%, general: 5%}
```

#### Сценарий 3: Авария
```
cranes_new = max(1, cranes - 2)  (-2 крана)
```

#### Сценарий 4: 50% доступность
```
cranes_new = cranes / 2
berths_new = berths / 2
```

#### Сценарий 5: Плохая погода
```
speed_new = speed × 0.7  (-30% скорость)
```

#### Сценарий 6: Одновременный приход судов
```
ships_new = ships_base × 1.5  (+50%)
```

---

## Используемые технологии

### 1. SimPy — Discrete Event Simulation

```python
env = simpy.Environment()  # Среда симуляции
resource = simpy.Resource(env, capacity=5)  # Ресурс (причал, кран)
container = simpy.Container(env, capacity=1000)  # Контейнер (склад)
```

**Основные концепции:**
- **Process** — независимый процесс (судно, поезд)
- **Resource** — ресурс с ограниченной емкостью (причалы, краны)
- **Container** — хранилище (склад)
- **Timeout** — задержка по времени

### 2. Streamlit — Web Interface

```python
st.number_input()  # Ввод параметров
st.plotly_chart()  # Графики
st.metric()        # Метрики
```

### 3. Plotly — Interactive Graphs

- Временные ряды (загрузка ресурсов)
- Гистограммы (распределение времени ожидания)
- Столбчатые диаграммы (сравнение пропускной способности)

---

## Структура кода

```
port_model.py
│
├── PortMetrics          # Сбор статистики
│   ├── record_ship_arrival()
│   ├── record_ship_processing()
│   └── record_resource_usage()
│
├── Port                 # Модель порта
│   ├── oil_berths       # simpy.Resource
│   ├── dry_berths       # simpy.Resource
│   ├── cranes           # simpy.Resource
│   ├── grain_storage    # simpy.Container
│   ├── general_storage  # simpy.Container
│   ├── oil_storage      # simpy.Container
│   └── railway          # simpy.Resource
│
├── ship_process()       # Процесс обработки судна
├── railway_unload_process()  # Процесс вывоза ЖД
├── ship_generator()     # Генератор прибытия судов
│
├── run_simulation()     # Запуск симуляции
├── calculate_capacity_metrics()  # Расчет метрик
├── find_collapse_point()  # Анализ коллапса
├── run_stress_scenarios()  # Стресс-тесты
│
└── main()               # Streamlit интерфейс
```

---

## Как работает дискретно-событийная симуляция

### Концепция:

Время в симуляции продвигается **скачками** от события к событию, а не непрерывно.

### События:
1. Прибытие судна
2. Начало швартовки
3. Начало разгрузки
4. Завершение разгрузки
5. Отправление поезда
6. И т.д.

### Пример временной шкалы:

```
t=0     Судно 1 прибыло
t=2     Судно 1 начало швартовку
t=3     Судно 2 прибыло (ждет в очереди)
t=22    Судно 1 завершило разгрузку
t=22    Судно 2 начало швартовку
t=24    Поезд увез груз
t=42    Судно 2 завершило разгрузку
...
```

---

## Запуск приложения

### Локально:

```bash
# Установка зависимостей
pip install -r requirements.txt

# Запуск
streamlit run port_model.py
```

### В облаке:

Приложение автоматически разворачивается на Streamlit Cloud при push в GitHub:

**URL**: https://portsimulator-yh67fp4m73pyahavovcpe4.streamlit.app

---

## Интерпретация результатов

### Основные вопросы, на которые отвечает модель:

#### 1. Какова пропускная способность порта?
```
Теоретический максимум = min(элементов инфраструктуры)
```

#### 2. Какой элемент является узким местом?
```
Элемент с минимальной пропускной способностью
```

#### 3. Выдержит ли порт целевую нагрузку?
```
if target_cargo <= system_capacity:
    ✅ Выдержит
else:
    ❌ Требуется модернизация
```

#### 4. Каков запас прочности?
```
reserve = system_capacity - current_load
```

#### 5. При какой нагрузке система рухнет?
```
Анализ точки коллапса → пороговые значения
```

---

## Ограничения модели

### Упрощения:

1. **Погода не учитывается** (кроме стресс-теста)
2. **Все суда одинаково обрабатываются** (нет приоритетов)
3. **Нет поломок оборудования** (кроме стресс-теста)
4. **Персонал всегда доступен**
5. **Таможенные процедуры не моделируются**

### Возможные улучшения:

- Сезонность грузопотока
- Разные типы судов (контейнеровозы, танкеры, балкеры)
- Приливы и отливы
- Погодные окна
- Стоимостный анализ (demurrage, простои)

---

## Автор

**Проект**: Симуляционная модель морского порта
**Технологии**: Python, SimPy, Streamlit, Plotly
**Год**: 2024

---

## Литература

1. **Discrete Event Simulation**: Banks, J. et al. "Discrete-Event System Simulation"
2. **Queueing Theory**: Kleinrock, L. "Queueing Systems"
3. **SimPy Documentation**: https://simpy.readthedocs.io/
4. **Port Logistics**: Mangan, J. "Global Logistics and Supply Chain Management"
